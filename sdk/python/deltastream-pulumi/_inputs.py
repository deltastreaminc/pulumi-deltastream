# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'EntityKafkaPropertiesArgs',
    'EntityKafkaPropertiesArgsDict',
    'EntityKinesisPropertiesArgs',
    'EntityKinesisPropertiesArgsDict',
    'EntityPostgresPropertiesArgs',
    'EntityPostgresPropertiesArgsDict',
    'EntitySnowflakePropertiesArgs',
    'EntitySnowflakePropertiesArgsDict',
    'SchemaRegistryConfluentArgs',
    'SchemaRegistryConfluentArgsDict',
    'SchemaRegistryConfluentCloudArgs',
    'SchemaRegistryConfluentCloudArgsDict',
    'StoreConfluentKafkaArgs',
    'StoreConfluentKafkaArgsDict',
    'StoreKafkaArgs',
    'StoreKafkaArgsDict',
    'StoreKinesisArgs',
    'StoreKinesisArgsDict',
    'StorePostgresArgs',
    'StorePostgresArgsDict',
    'StoreSnowflakeArgs',
    'StoreSnowflakeArgsDict',
    'GetStoreConfluentKafkaArgs',
    'GetStoreConfluentKafkaArgsDict',
    'GetStoreKafkaArgs',
    'GetStoreKafkaArgsDict',
    'GetStoreKinesisArgs',
    'GetStoreKinesisArgsDict',
    'GetStorePostgresArgs',
    'GetStorePostgresArgsDict',
    'GetStoreSnowflakeArgs',
    'GetStoreSnowflakeArgsDict',
]

MYPY = False

if not MYPY:
    class EntityKafkaPropertiesArgsDict(TypedDict):
        all_configs: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        All topic configurations including any server set configurations
        """
        configs: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Additional topic configurations
        """
        key_descriptor: NotRequired[pulumi.Input[builtins.str]]
        """
        Protobuf descriptor for key
        """
        topic_partitions: NotRequired[pulumi.Input[builtins.int]]
        """
        Number of partitions
        """
        topic_replicas: NotRequired[pulumi.Input[builtins.int]]
        """
        Number of replicas
        """
        value_descriptor: NotRequired[pulumi.Input[builtins.str]]
        """
        Protobuf descriptor for value
        """
elif False:
    EntityKafkaPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EntityKafkaPropertiesArgs:
    def __init__(__self__, *,
                 all_configs: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 configs: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 key_descriptor: Optional[pulumi.Input[builtins.str]] = None,
                 topic_partitions: Optional[pulumi.Input[builtins.int]] = None,
                 topic_replicas: Optional[pulumi.Input[builtins.int]] = None,
                 value_descriptor: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] all_configs: All topic configurations including any server set configurations
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] configs: Additional topic configurations
        :param pulumi.Input[builtins.str] key_descriptor: Protobuf descriptor for key
        :param pulumi.Input[builtins.int] topic_partitions: Number of partitions
        :param pulumi.Input[builtins.int] topic_replicas: Number of replicas
        :param pulumi.Input[builtins.str] value_descriptor: Protobuf descriptor for value
        """
        if all_configs is not None:
            pulumi.set(__self__, "all_configs", all_configs)
        if configs is not None:
            pulumi.set(__self__, "configs", configs)
        if key_descriptor is not None:
            pulumi.set(__self__, "key_descriptor", key_descriptor)
        if topic_partitions is not None:
            pulumi.set(__self__, "topic_partitions", topic_partitions)
        if topic_replicas is not None:
            pulumi.set(__self__, "topic_replicas", topic_replicas)
        if value_descriptor is not None:
            pulumi.set(__self__, "value_descriptor", value_descriptor)

    @property
    @pulumi.getter(name="allConfigs")
    def all_configs(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        All topic configurations including any server set configurations
        """
        return pulumi.get(self, "all_configs")

    @all_configs.setter
    def all_configs(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "all_configs", value)

    @property
    @pulumi.getter
    def configs(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Additional topic configurations
        """
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "configs", value)

    @property
    @pulumi.getter(name="keyDescriptor")
    def key_descriptor(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Protobuf descriptor for key
        """
        return pulumi.get(self, "key_descriptor")

    @key_descriptor.setter
    def key_descriptor(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "key_descriptor", value)

    @property
    @pulumi.getter(name="topicPartitions")
    def topic_partitions(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Number of partitions
        """
        return pulumi.get(self, "topic_partitions")

    @topic_partitions.setter
    def topic_partitions(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "topic_partitions", value)

    @property
    @pulumi.getter(name="topicReplicas")
    def topic_replicas(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Number of replicas
        """
        return pulumi.get(self, "topic_replicas")

    @topic_replicas.setter
    def topic_replicas(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "topic_replicas", value)

    @property
    @pulumi.getter(name="valueDescriptor")
    def value_descriptor(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Protobuf descriptor for value
        """
        return pulumi.get(self, "value_descriptor")

    @value_descriptor.setter
    def value_descriptor(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value_descriptor", value)


if not MYPY:
    class EntityKinesisPropertiesArgsDict(TypedDict):
        descriptor: NotRequired[pulumi.Input[builtins.str]]
        """
        Protobuf descriptor for the value
        """
        kinesis_shards: NotRequired[pulumi.Input[builtins.int]]
        """
        Number of shards
        """
elif False:
    EntityKinesisPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EntityKinesisPropertiesArgs:
    def __init__(__self__, *,
                 descriptor: Optional[pulumi.Input[builtins.str]] = None,
                 kinesis_shards: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] descriptor: Protobuf descriptor for the value
        :param pulumi.Input[builtins.int] kinesis_shards: Number of shards
        """
        if descriptor is not None:
            pulumi.set(__self__, "descriptor", descriptor)
        if kinesis_shards is not None:
            pulumi.set(__self__, "kinesis_shards", kinesis_shards)

    @property
    @pulumi.getter
    def descriptor(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Protobuf descriptor for the value
        """
        return pulumi.get(self, "descriptor")

    @descriptor.setter
    def descriptor(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "descriptor", value)

    @property
    @pulumi.getter(name="kinesisShards")
    def kinesis_shards(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Number of shards
        """
        return pulumi.get(self, "kinesis_shards")

    @kinesis_shards.setter
    def kinesis_shards(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "kinesis_shards", value)


if not MYPY:
    class EntityPostgresPropertiesArgsDict(TypedDict):
        details: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
elif False:
    EntityPostgresPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EntityPostgresPropertiesArgs:
    def __init__(__self__, *,
                 details: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None):
        if details is not None:
            pulumi.set(__self__, "details", details)

    @property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "details", value)


if not MYPY:
    class EntitySnowflakePropertiesArgsDict(TypedDict):
        details: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
elif False:
    EntitySnowflakePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EntitySnowflakePropertiesArgs:
    def __init__(__self__, *,
                 details: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None):
        if details is not None:
            pulumi.set(__self__, "details", details)

    @property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "details", value)


if not MYPY:
    class SchemaRegistryConfluentArgsDict(TypedDict):
        uris: pulumi.Input[builtins.str]
        """
        List of host:port URIs to connect to the schema registry
        """
        password: NotRequired[pulumi.Input[builtins.str]]
        """
        Password to use when authenticating with confluent schema registry
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        Username to use when authenticating with confluent schema registry
        """
elif False:
    SchemaRegistryConfluentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SchemaRegistryConfluentArgs:
    def __init__(__self__, *,
                 uris: pulumi.Input[builtins.str],
                 password: Optional[pulumi.Input[builtins.str]] = None,
                 username: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] uris: List of host:port URIs to connect to the schema registry
        :param pulumi.Input[builtins.str] password: Password to use when authenticating with confluent schema registry
        :param pulumi.Input[builtins.str] username: Username to use when authenticating with confluent schema registry
        """
        pulumi.set(__self__, "uris", uris)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def uris(self) -> pulumi.Input[builtins.str]:
        """
        List of host:port URIs to connect to the schema registry
        """
        return pulumi.get(self, "uris")

    @uris.setter
    def uris(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "uris", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Password to use when authenticating with confluent schema registry
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Username to use when authenticating with confluent schema registry
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class SchemaRegistryConfluentCloudArgsDict(TypedDict):
        uris: pulumi.Input[builtins.str]
        """
        List of host:port URIs to connect to the schema registry
        """
        key: NotRequired[pulumi.Input[builtins.str]]
        """
        Key to use when authenticating with confluent cloud schema registry
        """
        secret: NotRequired[pulumi.Input[builtins.str]]
        """
        Secret to use when authenticating with confluent cloud schema registry
        """
elif False:
    SchemaRegistryConfluentCloudArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SchemaRegistryConfluentCloudArgs:
    def __init__(__self__, *,
                 uris: pulumi.Input[builtins.str],
                 key: Optional[pulumi.Input[builtins.str]] = None,
                 secret: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] uris: List of host:port URIs to connect to the schema registry
        :param pulumi.Input[builtins.str] key: Key to use when authenticating with confluent cloud schema registry
        :param pulumi.Input[builtins.str] secret: Secret to use when authenticating with confluent cloud schema registry
        """
        pulumi.set(__self__, "uris", uris)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def uris(self) -> pulumi.Input[builtins.str]:
        """
        List of host:port URIs to connect to the schema registry
        """
        return pulumi.get(self, "uris")

    @uris.setter
    def uris(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "uris", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Key to use when authenticating with confluent cloud schema registry
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Secret to use when authenticating with confluent cloud schema registry
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class StoreConfluentKafkaArgsDict(TypedDict):
        sasl_hash_function: pulumi.Input[builtins.str]
        """
        SASL hash function to use when authenticating with Confluent Kafka brokers
        """
        sasl_password: pulumi.Input[builtins.str]
        """
        Password to use when authenticating with Apache Kafka brokers
        """
        sasl_username: pulumi.Input[builtins.str]
        """
        Username to use when authenticating with Apache Kafka brokers
        """
        uris: pulumi.Input[builtins.str]
        """
        List of host:port URIs to connect to the store
        """
elif False:
    StoreConfluentKafkaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StoreConfluentKafkaArgs:
    def __init__(__self__, *,
                 sasl_hash_function: pulumi.Input[builtins.str],
                 sasl_password: pulumi.Input[builtins.str],
                 sasl_username: pulumi.Input[builtins.str],
                 uris: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] sasl_hash_function: SASL hash function to use when authenticating with Confluent Kafka brokers
        :param pulumi.Input[builtins.str] sasl_password: Password to use when authenticating with Apache Kafka brokers
        :param pulumi.Input[builtins.str] sasl_username: Username to use when authenticating with Apache Kafka brokers
        :param pulumi.Input[builtins.str] uris: List of host:port URIs to connect to the store
        """
        pulumi.set(__self__, "sasl_hash_function", sasl_hash_function)
        pulumi.set(__self__, "sasl_password", sasl_password)
        pulumi.set(__self__, "sasl_username", sasl_username)
        pulumi.set(__self__, "uris", uris)

    @property
    @pulumi.getter(name="saslHashFunction")
    def sasl_hash_function(self) -> pulumi.Input[builtins.str]:
        """
        SASL hash function to use when authenticating with Confluent Kafka brokers
        """
        return pulumi.get(self, "sasl_hash_function")

    @sasl_hash_function.setter
    def sasl_hash_function(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "sasl_hash_function", value)

    @property
    @pulumi.getter(name="saslPassword")
    def sasl_password(self) -> pulumi.Input[builtins.str]:
        """
        Password to use when authenticating with Apache Kafka brokers
        """
        return pulumi.get(self, "sasl_password")

    @sasl_password.setter
    def sasl_password(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "sasl_password", value)

    @property
    @pulumi.getter(name="saslUsername")
    def sasl_username(self) -> pulumi.Input[builtins.str]:
        """
        Username to use when authenticating with Apache Kafka brokers
        """
        return pulumi.get(self, "sasl_username")

    @sasl_username.setter
    def sasl_username(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "sasl_username", value)

    @property
    @pulumi.getter
    def uris(self) -> pulumi.Input[builtins.str]:
        """
        List of host:port URIs to connect to the store
        """
        return pulumi.get(self, "uris")

    @uris.setter
    def uris(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "uris", value)


if not MYPY:
    class StoreKafkaArgsDict(TypedDict):
        sasl_hash_function: pulumi.Input[builtins.str]
        """
        SASL hash function to use when authenticating with Apache Kafka brokers
        """
        uris: pulumi.Input[builtins.str]
        """
        List of host:port URIs to connect to the store
        """
        msk_aws_region: NotRequired[pulumi.Input[builtins.str]]
        """
        AWS region where the Amazon MSK cluster is located
        """
        msk_iam_role_arn: NotRequired[pulumi.Input[builtins.str]]
        """
        IAM role ARN to use when authenticating with Amazon MSK
        """
        sasl_password: NotRequired[pulumi.Input[builtins.str]]
        """
        Password to use when authenticating with Apache Kafka brokers
        """
        sasl_username: NotRequired[pulumi.Input[builtins.str]]
        """
        Username to use when authenticating with Apache Kafka brokers
        """
        schema_registry_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the schema registry
        """
        tls_ca_cert_file: NotRequired[pulumi.Input[builtins.str]]
        """
        CA certificate in PEM format
        """
        tls_disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Specifies if the store should be accessed over TLS
        """
        tls_verify_server_hostname: NotRequired[pulumi.Input[builtins.bool]]
        """
        Specifies if the server CNAME should be validated against the certificate
        """
elif False:
    StoreKafkaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StoreKafkaArgs:
    def __init__(__self__, *,
                 sasl_hash_function: pulumi.Input[builtins.str],
                 uris: pulumi.Input[builtins.str],
                 msk_aws_region: Optional[pulumi.Input[builtins.str]] = None,
                 msk_iam_role_arn: Optional[pulumi.Input[builtins.str]] = None,
                 sasl_password: Optional[pulumi.Input[builtins.str]] = None,
                 sasl_username: Optional[pulumi.Input[builtins.str]] = None,
                 schema_registry_name: Optional[pulumi.Input[builtins.str]] = None,
                 tls_ca_cert_file: Optional[pulumi.Input[builtins.str]] = None,
                 tls_disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 tls_verify_server_hostname: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] sasl_hash_function: SASL hash function to use when authenticating with Apache Kafka brokers
        :param pulumi.Input[builtins.str] uris: List of host:port URIs to connect to the store
        :param pulumi.Input[builtins.str] msk_aws_region: AWS region where the Amazon MSK cluster is located
        :param pulumi.Input[builtins.str] msk_iam_role_arn: IAM role ARN to use when authenticating with Amazon MSK
        :param pulumi.Input[builtins.str] sasl_password: Password to use when authenticating with Apache Kafka brokers
        :param pulumi.Input[builtins.str] sasl_username: Username to use when authenticating with Apache Kafka brokers
        :param pulumi.Input[builtins.str] schema_registry_name: Name of the schema registry
        :param pulumi.Input[builtins.str] tls_ca_cert_file: CA certificate in PEM format
        :param pulumi.Input[builtins.bool] tls_disabled: Specifies if the store should be accessed over TLS
        :param pulumi.Input[builtins.bool] tls_verify_server_hostname: Specifies if the server CNAME should be validated against the certificate
        """
        pulumi.set(__self__, "sasl_hash_function", sasl_hash_function)
        pulumi.set(__self__, "uris", uris)
        if msk_aws_region is not None:
            pulumi.set(__self__, "msk_aws_region", msk_aws_region)
        if msk_iam_role_arn is not None:
            pulumi.set(__self__, "msk_iam_role_arn", msk_iam_role_arn)
        if sasl_password is not None:
            pulumi.set(__self__, "sasl_password", sasl_password)
        if sasl_username is not None:
            pulumi.set(__self__, "sasl_username", sasl_username)
        if schema_registry_name is not None:
            pulumi.set(__self__, "schema_registry_name", schema_registry_name)
        if tls_ca_cert_file is not None:
            pulumi.set(__self__, "tls_ca_cert_file", tls_ca_cert_file)
        if tls_disabled is not None:
            pulumi.set(__self__, "tls_disabled", tls_disabled)
        if tls_verify_server_hostname is not None:
            pulumi.set(__self__, "tls_verify_server_hostname", tls_verify_server_hostname)

    @property
    @pulumi.getter(name="saslHashFunction")
    def sasl_hash_function(self) -> pulumi.Input[builtins.str]:
        """
        SASL hash function to use when authenticating with Apache Kafka brokers
        """
        return pulumi.get(self, "sasl_hash_function")

    @sasl_hash_function.setter
    def sasl_hash_function(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "sasl_hash_function", value)

    @property
    @pulumi.getter
    def uris(self) -> pulumi.Input[builtins.str]:
        """
        List of host:port URIs to connect to the store
        """
        return pulumi.get(self, "uris")

    @uris.setter
    def uris(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "uris", value)

    @property
    @pulumi.getter(name="mskAwsRegion")
    def msk_aws_region(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        AWS region where the Amazon MSK cluster is located
        """
        return pulumi.get(self, "msk_aws_region")

    @msk_aws_region.setter
    def msk_aws_region(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "msk_aws_region", value)

    @property
    @pulumi.getter(name="mskIamRoleArn")
    def msk_iam_role_arn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        IAM role ARN to use when authenticating with Amazon MSK
        """
        return pulumi.get(self, "msk_iam_role_arn")

    @msk_iam_role_arn.setter
    def msk_iam_role_arn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "msk_iam_role_arn", value)

    @property
    @pulumi.getter(name="saslPassword")
    def sasl_password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Password to use when authenticating with Apache Kafka brokers
        """
        return pulumi.get(self, "sasl_password")

    @sasl_password.setter
    def sasl_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sasl_password", value)

    @property
    @pulumi.getter(name="saslUsername")
    def sasl_username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Username to use when authenticating with Apache Kafka brokers
        """
        return pulumi.get(self, "sasl_username")

    @sasl_username.setter
    def sasl_username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sasl_username", value)

    @property
    @pulumi.getter(name="schemaRegistryName")
    def schema_registry_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the schema registry
        """
        return pulumi.get(self, "schema_registry_name")

    @schema_registry_name.setter
    def schema_registry_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "schema_registry_name", value)

    @property
    @pulumi.getter(name="tlsCaCertFile")
    def tls_ca_cert_file(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        CA certificate in PEM format
        """
        return pulumi.get(self, "tls_ca_cert_file")

    @tls_ca_cert_file.setter
    def tls_ca_cert_file(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tls_ca_cert_file", value)

    @property
    @pulumi.getter(name="tlsDisabled")
    def tls_disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Specifies if the store should be accessed over TLS
        """
        return pulumi.get(self, "tls_disabled")

    @tls_disabled.setter
    def tls_disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "tls_disabled", value)

    @property
    @pulumi.getter(name="tlsVerifyServerHostname")
    def tls_verify_server_hostname(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Specifies if the server CNAME should be validated against the certificate
        """
        return pulumi.get(self, "tls_verify_server_hostname")

    @tls_verify_server_hostname.setter
    def tls_verify_server_hostname(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "tls_verify_server_hostname", value)


if not MYPY:
    class StoreKinesisArgsDict(TypedDict):
        aws_account_id: pulumi.Input[builtins.str]
        """
        AWS account ID to use when authenticating with an Amazon Kinesis service
        """
        uris: pulumi.Input[builtins.str]
        """
        List of host:port URIs to connect to the store
        """
        access_key_id: NotRequired[pulumi.Input[builtins.str]]
        """
        AWS IAM access key to use when authenticating with an Amazon Kinesis service
        """
        secret_access_key: NotRequired[pulumi.Input[builtins.str]]
        """
        AWS IAM secret access key to use when authenticating with an Amazon Kinesis service
        """
elif False:
    StoreKinesisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StoreKinesisArgs:
    def __init__(__self__, *,
                 aws_account_id: pulumi.Input[builtins.str],
                 uris: pulumi.Input[builtins.str],
                 access_key_id: Optional[pulumi.Input[builtins.str]] = None,
                 secret_access_key: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] aws_account_id: AWS account ID to use when authenticating with an Amazon Kinesis service
        :param pulumi.Input[builtins.str] uris: List of host:port URIs to connect to the store
        :param pulumi.Input[builtins.str] access_key_id: AWS IAM access key to use when authenticating with an Amazon Kinesis service
        :param pulumi.Input[builtins.str] secret_access_key: AWS IAM secret access key to use when authenticating with an Amazon Kinesis service
        """
        pulumi.set(__self__, "aws_account_id", aws_account_id)
        pulumi.set(__self__, "uris", uris)
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> pulumi.Input[builtins.str]:
        """
        AWS account ID to use when authenticating with an Amazon Kinesis service
        """
        return pulumi.get(self, "aws_account_id")

    @aws_account_id.setter
    def aws_account_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "aws_account_id", value)

    @property
    @pulumi.getter
    def uris(self) -> pulumi.Input[builtins.str]:
        """
        List of host:port URIs to connect to the store
        """
        return pulumi.get(self, "uris")

    @uris.setter
    def uris(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "uris", value)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        AWS IAM access key to use when authenticating with an Amazon Kinesis service
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "access_key_id", value)

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        AWS IAM secret access key to use when authenticating with an Amazon Kinesis service
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "secret_access_key", value)


if not MYPY:
    class StorePostgresArgsDict(TypedDict):
        password: pulumi.Input[builtins.str]
        """
        Password to use when authenticating with a Postgres database
        """
        uris: pulumi.Input[builtins.str]
        """
        List of host:port URIs to connect to the store
        """
        username: pulumi.Input[builtins.str]
        """
        Username to use when authenticating with a Postgres database
        """
elif False:
    StorePostgresArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorePostgresArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[builtins.str],
                 uris: pulumi.Input[builtins.str],
                 username: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] password: Password to use when authenticating with a Postgres database
        :param pulumi.Input[builtins.str] uris: List of host:port URIs to connect to the store
        :param pulumi.Input[builtins.str] username: Username to use when authenticating with a Postgres database
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "uris", uris)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[builtins.str]:
        """
        Password to use when authenticating with a Postgres database
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def uris(self) -> pulumi.Input[builtins.str]:
        """
        List of host:port URIs to connect to the store
        """
        return pulumi.get(self, "uris")

    @uris.setter
    def uris(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "uris", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[builtins.str]:
        """
        Username to use when authenticating with a Postgres database
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class StoreSnowflakeArgsDict(TypedDict):
        account_id: pulumi.Input[builtins.str]
        """
        Snowflake account ID
        """
        client_key_file: pulumi.Input[builtins.str]
        """
        Snowflake account's private key in PEM format
        """
        client_key_passphrase: pulumi.Input[builtins.str]
        """
        Passphrase for decrypting the Snowflake account's private key
        """
        cloud_region: pulumi.Input[builtins.str]
        """
        Snowflake cloud region name, where the account resources operate in
        """
        role_name: pulumi.Input[builtins.str]
        """
        Access control role to use for the Store operations after connecting to Snowflake
        """
        uris: pulumi.Input[builtins.str]
        """
        List of host:port URIs to connect to the store
        """
        username: pulumi.Input[builtins.str]
        """
        User login name for the Snowflake account
        """
        warehouse_name: pulumi.Input[builtins.str]
        """
        Warehouse name to use for queries and other store operations that require compute resource
        """
elif False:
    StoreSnowflakeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StoreSnowflakeArgs:
    def __init__(__self__, *,
                 account_id: pulumi.Input[builtins.str],
                 client_key_file: pulumi.Input[builtins.str],
                 client_key_passphrase: pulumi.Input[builtins.str],
                 cloud_region: pulumi.Input[builtins.str],
                 role_name: pulumi.Input[builtins.str],
                 uris: pulumi.Input[builtins.str],
                 username: pulumi.Input[builtins.str],
                 warehouse_name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] account_id: Snowflake account ID
        :param pulumi.Input[builtins.str] client_key_file: Snowflake account's private key in PEM format
        :param pulumi.Input[builtins.str] client_key_passphrase: Passphrase for decrypting the Snowflake account's private key
        :param pulumi.Input[builtins.str] cloud_region: Snowflake cloud region name, where the account resources operate in
        :param pulumi.Input[builtins.str] role_name: Access control role to use for the Store operations after connecting to Snowflake
        :param pulumi.Input[builtins.str] uris: List of host:port URIs to connect to the store
        :param pulumi.Input[builtins.str] username: User login name for the Snowflake account
        :param pulumi.Input[builtins.str] warehouse_name: Warehouse name to use for queries and other store operations that require compute resource
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "client_key_file", client_key_file)
        pulumi.set(__self__, "client_key_passphrase", client_key_passphrase)
        pulumi.set(__self__, "cloud_region", cloud_region)
        pulumi.set(__self__, "role_name", role_name)
        pulumi.set(__self__, "uris", uris)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "warehouse_name", warehouse_name)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> pulumi.Input[builtins.str]:
        """
        Snowflake account ID
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "account_id", value)

    @property
    @pulumi.getter(name="clientKeyFile")
    def client_key_file(self) -> pulumi.Input[builtins.str]:
        """
        Snowflake account's private key in PEM format
        """
        return pulumi.get(self, "client_key_file")

    @client_key_file.setter
    def client_key_file(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "client_key_file", value)

    @property
    @pulumi.getter(name="clientKeyPassphrase")
    def client_key_passphrase(self) -> pulumi.Input[builtins.str]:
        """
        Passphrase for decrypting the Snowflake account's private key
        """
        return pulumi.get(self, "client_key_passphrase")

    @client_key_passphrase.setter
    def client_key_passphrase(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "client_key_passphrase", value)

    @property
    @pulumi.getter(name="cloudRegion")
    def cloud_region(self) -> pulumi.Input[builtins.str]:
        """
        Snowflake cloud region name, where the account resources operate in
        """
        return pulumi.get(self, "cloud_region")

    @cloud_region.setter
    def cloud_region(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "cloud_region", value)

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> pulumi.Input[builtins.str]:
        """
        Access control role to use for the Store operations after connecting to Snowflake
        """
        return pulumi.get(self, "role_name")

    @role_name.setter
    def role_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "role_name", value)

    @property
    @pulumi.getter
    def uris(self) -> pulumi.Input[builtins.str]:
        """
        List of host:port URIs to connect to the store
        """
        return pulumi.get(self, "uris")

    @uris.setter
    def uris(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "uris", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[builtins.str]:
        """
        User login name for the Snowflake account
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="warehouseName")
    def warehouse_name(self) -> pulumi.Input[builtins.str]:
        """
        Warehouse name to use for queries and other store operations that require compute resource
        """
        return pulumi.get(self, "warehouse_name")

    @warehouse_name.setter
    def warehouse_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "warehouse_name", value)


if not MYPY:
    class GetStoreConfluentKafkaArgsDict(TypedDict):
        schema_registry_name: builtins.str
        """
        Name of the schema registry
        """
        uris: builtins.str
        """
        List of host:port URIs to connect to the store
        """
elif False:
    GetStoreConfluentKafkaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetStoreConfluentKafkaArgs:
    def __init__(__self__, *,
                 schema_registry_name: builtins.str,
                 uris: builtins.str):
        """
        :param builtins.str schema_registry_name: Name of the schema registry
        :param builtins.str uris: List of host:port URIs to connect to the store
        """
        pulumi.set(__self__, "schema_registry_name", schema_registry_name)
        pulumi.set(__self__, "uris", uris)

    @property
    @pulumi.getter(name="schemaRegistryName")
    def schema_registry_name(self) -> builtins.str:
        """
        Name of the schema registry
        """
        return pulumi.get(self, "schema_registry_name")

    @schema_registry_name.setter
    def schema_registry_name(self, value: builtins.str):
        pulumi.set(self, "schema_registry_name", value)

    @property
    @pulumi.getter
    def uris(self) -> builtins.str:
        """
        List of host:port URIs to connect to the store
        """
        return pulumi.get(self, "uris")

    @uris.setter
    def uris(self, value: builtins.str):
        pulumi.set(self, "uris", value)


if not MYPY:
    class GetStoreKafkaArgsDict(TypedDict):
        schema_registry_name: builtins.str
        """
        Name of the schema registry
        """
        tls_disabled: builtins.bool
        """
        Specifies if the store should be accessed over TLS
        """
        tls_verify_server_hostname: builtins.bool
        """
        Specifies if the server CNAME should be validated against the certificate
        """
        uris: builtins.str
        """
        List of host:port URIs to connect to the store
        """
elif False:
    GetStoreKafkaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetStoreKafkaArgs:
    def __init__(__self__, *,
                 schema_registry_name: builtins.str,
                 tls_disabled: builtins.bool,
                 tls_verify_server_hostname: builtins.bool,
                 uris: builtins.str):
        """
        :param builtins.str schema_registry_name: Name of the schema registry
        :param builtins.bool tls_disabled: Specifies if the store should be accessed over TLS
        :param builtins.bool tls_verify_server_hostname: Specifies if the server CNAME should be validated against the certificate
        :param builtins.str uris: List of host:port URIs to connect to the store
        """
        pulumi.set(__self__, "schema_registry_name", schema_registry_name)
        pulumi.set(__self__, "tls_disabled", tls_disabled)
        pulumi.set(__self__, "tls_verify_server_hostname", tls_verify_server_hostname)
        pulumi.set(__self__, "uris", uris)

    @property
    @pulumi.getter(name="schemaRegistryName")
    def schema_registry_name(self) -> builtins.str:
        """
        Name of the schema registry
        """
        return pulumi.get(self, "schema_registry_name")

    @schema_registry_name.setter
    def schema_registry_name(self, value: builtins.str):
        pulumi.set(self, "schema_registry_name", value)

    @property
    @pulumi.getter(name="tlsDisabled")
    def tls_disabled(self) -> builtins.bool:
        """
        Specifies if the store should be accessed over TLS
        """
        return pulumi.get(self, "tls_disabled")

    @tls_disabled.setter
    def tls_disabled(self, value: builtins.bool):
        pulumi.set(self, "tls_disabled", value)

    @property
    @pulumi.getter(name="tlsVerifyServerHostname")
    def tls_verify_server_hostname(self) -> builtins.bool:
        """
        Specifies if the server CNAME should be validated against the certificate
        """
        return pulumi.get(self, "tls_verify_server_hostname")

    @tls_verify_server_hostname.setter
    def tls_verify_server_hostname(self, value: builtins.bool):
        pulumi.set(self, "tls_verify_server_hostname", value)

    @property
    @pulumi.getter
    def uris(self) -> builtins.str:
        """
        List of host:port URIs to connect to the store
        """
        return pulumi.get(self, "uris")

    @uris.setter
    def uris(self, value: builtins.str):
        pulumi.set(self, "uris", value)


if not MYPY:
    class GetStoreKinesisArgsDict(TypedDict):
        schema_registry_name: builtins.str
        """
        Name of the schema registry
        """
        uris: builtins.str
        """
        List of host:port URIs to connect to the store
        """
elif False:
    GetStoreKinesisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetStoreKinesisArgs:
    def __init__(__self__, *,
                 schema_registry_name: builtins.str,
                 uris: builtins.str):
        """
        :param builtins.str schema_registry_name: Name of the schema registry
        :param builtins.str uris: List of host:port URIs to connect to the store
        """
        pulumi.set(__self__, "schema_registry_name", schema_registry_name)
        pulumi.set(__self__, "uris", uris)

    @property
    @pulumi.getter(name="schemaRegistryName")
    def schema_registry_name(self) -> builtins.str:
        """
        Name of the schema registry
        """
        return pulumi.get(self, "schema_registry_name")

    @schema_registry_name.setter
    def schema_registry_name(self, value: builtins.str):
        pulumi.set(self, "schema_registry_name", value)

    @property
    @pulumi.getter
    def uris(self) -> builtins.str:
        """
        List of host:port URIs to connect to the store
        """
        return pulumi.get(self, "uris")

    @uris.setter
    def uris(self, value: builtins.str):
        pulumi.set(self, "uris", value)


if not MYPY:
    class GetStorePostgresArgsDict(TypedDict):
        uris: builtins.str
        """
        List of host:port URIs to connect to the store
        """
elif False:
    GetStorePostgresArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetStorePostgresArgs:
    def __init__(__self__, *,
                 uris: builtins.str):
        """
        :param builtins.str uris: List of host:port URIs to connect to the store
        """
        pulumi.set(__self__, "uris", uris)

    @property
    @pulumi.getter
    def uris(self) -> builtins.str:
        """
        List of host:port URIs to connect to the store
        """
        return pulumi.get(self, "uris")

    @uris.setter
    def uris(self, value: builtins.str):
        pulumi.set(self, "uris", value)


if not MYPY:
    class GetStoreSnowflakeArgsDict(TypedDict):
        account_id: builtins.str
        """
        Snowflake account ID
        """
        role_name: builtins.str
        """
        Access control role to use for the Store operations after connecting to Snowflake
        """
        uris: builtins.str
        """
        List of host:port URIs to connect to the store
        """
        warehouse_name: builtins.str
        """
        Warehouse name to use for queries and other store operations that require compute resource
        """
elif False:
    GetStoreSnowflakeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetStoreSnowflakeArgs:
    def __init__(__self__, *,
                 account_id: builtins.str,
                 role_name: builtins.str,
                 uris: builtins.str,
                 warehouse_name: builtins.str):
        """
        :param builtins.str account_id: Snowflake account ID
        :param builtins.str role_name: Access control role to use for the Store operations after connecting to Snowflake
        :param builtins.str uris: List of host:port URIs to connect to the store
        :param builtins.str warehouse_name: Warehouse name to use for queries and other store operations that require compute resource
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "role_name", role_name)
        pulumi.set(__self__, "uris", uris)
        pulumi.set(__self__, "warehouse_name", warehouse_name)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> builtins.str:
        """
        Snowflake account ID
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: builtins.str):
        pulumi.set(self, "account_id", value)

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> builtins.str:
        """
        Access control role to use for the Store operations after connecting to Snowflake
        """
        return pulumi.get(self, "role_name")

    @role_name.setter
    def role_name(self, value: builtins.str):
        pulumi.set(self, "role_name", value)

    @property
    @pulumi.getter
    def uris(self) -> builtins.str:
        """
        List of host:port URIs to connect to the store
        """
        return pulumi.get(self, "uris")

    @uris.setter
    def uris(self, value: builtins.str):
        pulumi.set(self, "uris", value)

    @property
    @pulumi.getter(name="warehouseName")
    def warehouse_name(self) -> builtins.str:
        """
        Warehouse name to use for queries and other store operations that require compute resource
        """
        return pulumi.get(self, "warehouse_name")

    @warehouse_name.setter
    def warehouse_name(self, value: builtins.str):
        pulumi.set(self, "warehouse_name", value)


